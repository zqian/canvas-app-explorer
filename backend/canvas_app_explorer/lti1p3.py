import logging, random, string, urllib.parse
from collections import namedtuple
from datetime import datetime
from typing import Any, Dict, Union

from django.conf import settings
from django.contrib.auth import login as django_login
from django.contrib.auth.models import User
from django.core.exceptions import PermissionDenied
from django.http import HttpRequest, HttpResponse, HttpResponseForbidden, JsonResponse
from django.shortcuts import redirect
from django.urls import reverse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from pylti1p3.contrib.django import (
    DjangoCacheDataStorage, DjangoDbToolConf, DjangoMessageLaunch, DjangoOIDCLogin
)
from pylti1p3.exception import LtiException

from .canvas_roles import STAFF_COURSE_ROLES


logger = logging.getLogger(__name__)

COURSE_MEMBERSHIP = 'http://purl.imsglobal.org/vocab/lis/v2/membership'
TOOL_CONF = DjangoDbToolConf()

CacheConfig = namedtuple('CacheConfig', ['launch_data_storage', 'cache_lifetime'])


def extract_error_message(error: Exception) -> Union[str, None]:
    """
    Check Exception for a string message as the first position argument.
    """
    if len(error.args) >= 1 and isinstance(error.args[0], str):
        return error.args[0]
    return None

# Custom LTI variable keys
USERNAME_KEY = 'user_username'
COURSE_ID_KEY = 'canvas_course_id'
COURSE_TERM_ID_KEY = 'canvas_term_id'
COURSE_TERM_NAME_KEY = 'canvas_term_name'
COURSE_ACCOUNT_ID_KEY = 'canvas_course_account_id'
COURSE_ACCOUNT_NAME_KEY = 'canvas_course_account_name'
COURSE_ROLES_KEY = 'canvas_course_roles'


class LTILaunchError(Exception):
    """
    Exception class for errors that occur while processing data from the LTI launch
    """


# do not require deployment ids if LTI_CONFIG_DISABLE_DEPLOYMENT_ID_VALIDATION is true
class ExtendedDjangoMessageLaunch(DjangoMessageLaunch):
    def validate_deployment(self):
        # Check the deployment id is set otherwise the code will raise an exception
        if settings.LTI_CONFIG_DISABLE_DEPLOYMENT_ID_VALIDATION and self._get_deployment_id():
            return self

        return super().validate_deployment()


def lti_error(error_message: Any) -> JsonResponse:
    """
    Log an error message and return a JSON response with HTTP status 500.

    :param error_message: `Any` type is allowed so objects may be used
    :return: JsonResponse, with status 500
    """
    logger.error(f'LTI error: {error_message}')
    return JsonResponse({'lti_error': f'{error_message}'}, status=500)


def generate_jwks() -> Dict[str, list]:
    return TOOL_CONF.get_jwks()


def get_jwks(_: Any) -> JsonResponse:
    """
    Return JWKS generated by `pylti1p3`, based on public key

    :param _: Django passes a Request object, but this method doesn't use it.
    :return: `JsonResponse` containing JWKS or error message.
    """
    try:
        jwks = generate_jwks()
    except Exception as e:
        return lti_error(e)
    return JsonResponse(jwks)


def generate_config_json(request: HttpRequest) -> \
        Union[HttpResponse, JsonResponse]:
    parameters = {
        'timestamp': datetime.now().isoformat(),
        'host': request.get_host(),
        'base_url': urllib.parse.urlunsplit(
            [request.scheme, request.get_host()] + 3 * ['']),
        'login_url_suffix': reverse('lti_login'),
        'launch_url_suffix': reverse('lti_launch'),
        'jwks_url_suffix': reverse('lti_get_jwks'),
    }

    template_path = 'templates/lti_config_template.json'

    logger.debug(f'template_path: "{template_path}"')

    template_contents: str
    try:
        with open(template_path, 'r') as template_file:
            template_contents = template_file.read()
    except OSError as error:
        return lti_error('Error reading LTI template file '
                         f'"{template_path}": ({error})')

    config_json: str
    try:
        config_json = template_contents % parameters
    except KeyError as error:
        return lti_error('Error filling in LTI template from '
                         f'"{template_path}": ({error})')

    return HttpResponse(config_json, content_type='application/json')


def get_cache_config() -> CacheConfig:
    launch_data_storage = DjangoCacheDataStorage()
    cache_ttl = settings.DB_CACHE_CONFIGS['CACHE_TTL']
    cache_lifetime = cache_ttl if cache_ttl else 7200
    return CacheConfig(launch_data_storage, cache_lifetime)


def create_user_in_django(request: HttpRequest, launch_data: Dict[str, Any]):
    logger.debug(f'lti launch data {launch_data}')
    custom_params = launch_data['https://purl.imsglobal.org/spec/lti/claim/custom']
    logger.debug(f'lti_custom_param {custom_params}')
    if not custom_params:
        raise LTILaunchError(
            'You need to have custom parameters configured on your LTI Launch. ' +
            'Please see the LTI installation guide on the Github Wiki for more information.'
        )

    if not set([USERNAME_KEY, COURSE_ID_KEY, COURSE_ROLES_KEY]).issubset(set(custom_params.keys())):
        raise LTILaunchError(
            'One or more required custom LTI variables were not defined. ' +
            f'These variables are required: {", ".join([USERNAME_KEY, COURSE_ID_KEY, COURSE_ROLES_KEY])}'
        )

    course_name = launch_data['https://purl.imsglobal.org/spec/lti/claim/context']['title']
    roles = launch_data['https://purl.imsglobal.org/spec/lti/claim/roles']

    username = custom_params[USERNAME_KEY]
    course_id = custom_params[COURSE_ID_KEY]
    term_id = custom_params[COURSE_TERM_ID_KEY] if COURSE_TERM_ID_KEY in custom_params else None
    term_name = custom_params[COURSE_TERM_NAME_KEY] if COURSE_TERM_NAME_KEY in custom_params else None
    account_id = custom_params[COURSE_ACCOUNT_ID_KEY] if COURSE_ACCOUNT_ID_KEY in custom_params else None
    account_name = custom_params[COURSE_ACCOUNT_NAME_KEY] if COURSE_ACCOUNT_NAME_KEY in custom_params else None
    course_roles = custom_params[COURSE_ROLES_KEY].split(',')

    if 'email' not in launch_data.keys():
        logger.warning('An instructor/admin likely launched the tool using Student View (Test Student).')
        error_message = 'Student View is not available for Canvas App Explorer.'
        raise PermissionDenied(error_message)

    staff_course_role_values = [role.value for role in STAFF_COURSE_ROLES]
    user_staff_course_roles = [course_role for course_role in course_roles if course_role in staff_course_role_values]
    user_is_course_staff = len(user_staff_course_roles) > 0

    if not user_is_course_staff:
        logger.warning(f'User {username} does not have a staff role.')
        error_message = 'You must be an instructor in this course or an administrator to access this tool.'
        raise PermissionDenied(error_message)

    email = launch_data['email']
    first_name = launch_data['given_name']
    last_name = launch_data['family_name']
    full_name = launch_data['name']
    user_sis_id = launch_data['https://purl.imsglobal.org/spec/lti/claim/lis']['person_sourcedid']

    # Add user to DB if not there; avoids Django redirection to login page
    try:
        user_obj = User.objects.get(username=username)
        # update
        user_obj.first_name = first_name
        user_obj.last_name = last_name
        user_obj.email = email
        user_obj.save()
    except User.DoesNotExist:
        password = ''.join(random.sample(string.ascii_letters, settings.RANDOM_PASSWORD_DEFAULT_LENGTH))
        user_obj = User.objects.create_user(username=username, email=email, password=password, first_name=first_name,
                                            last_name=last_name)
    user_obj.backend = 'django.contrib.auth.backends.ModelBackend'
    django_login(request, user_obj)

    if course_id is not None:
        try:
            course_id_int = int(course_id)
        except ValueError:
            raise LTILaunchError(f'Course ID from LTI launch cannot be converted to an integer. Value: {course_id}')

        request.session['course_id'] = course_id_int
        request.session['course_name'] = course_name
        request.session['term_id'] = term_id
        request.session['term_name'] = term_name
        request.session['account_id'] = account_id
        request.session['account_name'] = account_name
    else:
        raise LTILaunchError(f'Course ID from LTI launch cannot be null.')


@csrf_exempt
def login(request: HttpRequest):
    cache_config = get_cache_config()
    target_link_uri = request.POST.get('target_link_uri', request.GET.get('target_link_uri'))
    if not target_link_uri:
        error_message = 'LTI Login failed due to missing "target_link_uri" param'
        return lti_error(error_message)
    oidc_login = DjangoOIDCLogin(request, TOOL_CONF, launch_data_storage=cache_config.launch_data_storage)
    return oidc_login.enable_check_cookies().redirect(target_link_uri)


@require_POST
@csrf_exempt
def launch(request: HttpRequest):
    cache_config = get_cache_config()
    message_launch = ExtendedDjangoMessageLaunch(request, TOOL_CONF, launch_data_storage=cache_config.launch_data_storage)
    message_launch.set_public_key_caching(cache_config.launch_data_storage, cache_config.cache_lifetime)

    try:
        launch_data: Dict[str, Any] = message_launch.get_launch_data()
    except LtiException as lti_exception:
        logger.error(lti_exception)
        message = f'LTI launch error occurred. Please try launching the tool again.'
        error_message = extract_error_message(lti_exception)
        if error_message:
            message += f' Error: {error_message}.'
        response = HttpResponse(message)
        response.status_code = 401
        return response

    # TODO: Implement custom AUTHENTICATION_BACKEND rather than using this one
    try:
        create_user_in_django(request, launch_data)
    except PermissionDenied as e:
        message = 'Permission denied.'
        error_message = extract_error_message(e)
        if error_message:
            message += ' ' + error_message
        return HttpResponseForbidden(message)

    url = reverse('home')
    return redirect(url)
